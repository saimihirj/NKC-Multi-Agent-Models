# -*- coding: utf-8 -*-
"""NKC Models

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a5jIm4oocCfD-g0HQu253U4r92nYOCAT
"""

import random
import numpy as np
import pandas as pd
import os

"""### **Modular Case**"""

# -------------------------------
# Updating Rule for Body-1 (N1, K1)
# -------------------------------
def create_updated_array(N1, K1, initial_seed=None):
    """Generates an updated array for Body-1 using a sliding window update rule based on K1."""
    if K1 <= 0:
        return [0] * N1  # No updating, return fixed array.

    if initial_seed is None or len(initial_seed) != K1:
        initial_seed = [random.choice([0, 1]) for _ in range(K1)]

    result = list(initial_seed)

    while len(result) < N1:
        window = result[-K1:]
        avg = sum(window) / K1
        next_element = 1 if avg >= 0.5 else 0
        result.append(next_element)

    return result

# -------------------------------
# Updating Rule for Body-2 (N2, K2)
# -------------------------------
def create_updated_array_n2(N2, K2, initial_seed=None):
    """Generates an updated array for Body-2 using a weighted sliding window update rule based on K2."""
    if K2 <= 0:
        return [0] * N2

    if initial_seed is None or len(initial_seed) != K2:
        initial_seed = [random.choice([0, 1]) for _ in range(K2)]

    result = list(initial_seed)
    total_weight = sum(range(1, K2 + 1))

    while len(result) < N2:
        window = result[-K2:]
        weighted_sum = sum((i + 1) * window[i] for i in range(K2))
        next_element = 1 if weighted_sum >= total_weight / 2 else 0
        result.append(next_element)

    return result

# -------------------------------
# Fitness and Local Peaks Calculation
# -------------------------------
def compute_fitness(array, K):
    """Computes the fitness (payoff) based on the interactions in the array."""
    N = len(array)
    if N == 0:
        return 0

    total_fitness = 0
    for i in range(N):
        interacting_indices = [(i + j) % N for j in range(K + 1)]
        interacting_values = [array[j] for j in interacting_indices]
        fitness_contribution = sum(interacting_values) % 2
        total_fitness += fitness_contribution

    return total_fitness / N

def count_local_peaks(array):
    """Counts the number of local peaks in an array."""
    N = len(array)
    if N == 0:
        return 0

    peak_count = 0
    for i in range(N):
        left_neighbor = array[i - 1] if i > 0 else array[N - 1]
        right_neighbor = array[i + 1] if i < N - 1 else array[0]

        if array[i] >= left_neighbor and array[i] >= right_neighbor:
            peak_count += 1

    return peak_count

def compute_payoff(array, K):
    """Computes both the fitness (payoff) and the number of local peaks."""
    fitness = compute_fitness(array, K)
    local_peaks = count_local_peaks(array)

    return {'payoff': fitness, 'local_peaks': local_peaks}

# -------------------------------
# Modular Simulation Case (No Interaction)
# -------------------------------
def simulate_modular(iteration, N1, K1, N2, K2):
    """Simulates the modular case where both bodies operate independently."""
    body1 = create_updated_array(N1, K1)
    body2 = create_updated_array_n2(N2, K2)

    payoff_body1 = compute_payoff(body1, K1)
    payoff_body2 = compute_payoff(body2, K2)

    avg_payoff = (payoff_body1['payoff'] + payoff_body2['payoff']) / 2

    return {
        'Simulation': iteration,
        'N_AI': N1, 'K_AI': K1, 'N_Human': N2, 'K_Human': K2, 'C': 0,
        'LP_AI': payoff_body1['local_peaks'],
        'PO_AI': payoff_body1['payoff'],
        'UA_AI': body1,
        'LP_Human': payoff_body2['local_peaks'],
        'PO_Human': payoff_body2['payoff'],
        'UA_Human': body2,
        'APO_Modular': avg_payoff
    }

# -------------------------------------
# MAIN SIMULATION EXECUTION
# -------------------------------------
def main_simulation(iteration):
    # Define parameter ranges
    N1_values = range(1, 51)
    N2_values = range(1, 11)
    # K1_values = range(0, 10)
    # K2_values = range(0, 10)

    # Generate all valid configurations (K1 < N1, K2 < N2)
    configs = [(N1, K1, N2, K2)
               for N1 in N1_values for K1 in range(0, N1)
               for N2 in N2_values for K2 in range(0, N2)]

    results = []

    for config in configs:
        N1, K1, N2, K2 = config
        result = simulate_modular(iteration, N1, K1, N2, K2)
        results.append(result)
        print(result)  # Print structured output

    # Convert to DataFrame for structured output
    results_df = pd.DataFrame(results)

    # Define the filename
    filename = "modular_simulation_results.csv"

    # Check if file exists -> Append data (without writing the header again)
    if os.path.exists(filename):
        results_df.to_csv(filename, mode='a', header=False, index=False)
    else:
        results_df.to_csv(filename, mode='w', header=True, index=False)

    return results_df

# -------------------------------------
# EXECUTION ENTRY POINT
# -------------------------------------
if __name__ == "__main__":
    for iteration_id in range(1, 11):  # Example: Running 10 iterations
        df = main_simulation(iteration_id)
        print(f"Iteration {iteration_id} completed.")
    print("All iterations completed.")

"""### **ATH Sequence**"""

# -------------------------------
# Updating Rule for Body-1 (N1, K1)
# -------------------------------
def create_updated_array(N1, K1, initial_seed=None):
    """Generates an updated array for Body-1 using a sliding window update rule based on K1."""
    if K1 <= 0:
        return [0] * N1  # No updating, return fixed array.

    if initial_seed is None or len(initial_seed) != K1:
        initial_seed = [random.choice([0, 1]) for _ in range(K1)]

    result = list(initial_seed)

    while len(result) < N1:
        window = result[-K1:]
        avg = sum(window) / K1
        next_element = 1 if avg >= 0.5 else 0
        result.append(next_element)

    return result

# -------------------------------
# Updating Rule for Body-2 (N2, K2)
# -------------------------------
def create_updated_array_n2(N2, K2, initial_seed=None):
    """Generates an updated array for Body-2 using a weighted sliding window update rule based on K2."""
    if K2 <= 0:
        return [0] * N2

    if initial_seed is None or len(initial_seed) != K2:
        initial_seed = [random.choice([0, 1]) for _ in range(K2)]

    result = list(initial_seed)
    total_weight = sum(range(1, K2 + 1))

    while len(result) < N2:
        window = result[-K2:]
        weighted_sum = sum((i + 1) * window[i] for i in range(K2))
        next_element = 1 if weighted_sum >= total_weight / 2 else 0
        result.append(next_element)

    return result

# -------------------------------
# Fitness and Local Peaks Calculation
# -------------------------------
def compute_fitness(array, K):
    """Computes the fitness (payoff) based on the interactions in the array."""
    N = len(array)
    if N == 0:
        return 0

    total_fitness = 0
    for i in range(N):
        interacting_indices = [(i + j) % N for j in range(K + 1)]
        interacting_values = [array[j] for j in interacting_indices]
        fitness_contribution = sum(interacting_values) % 2
        total_fitness += fitness_contribution

    return total_fitness / N

def count_local_peaks(array):
    """Counts the number of local peaks in an array."""
    N = len(array)
    if N == 0:
        return 0

    peak_count = 0
    for i in range(N):
        left_neighbor = array[i - 1] if i > 0 else array[N - 1]
        right_neighbor = array[i + 1] if i < N - 1 else array[0]

        if array[i] >= left_neighbor and array[i] >= right_neighbor:
            peak_count += 1

    return peak_count

def compute_payoff(array, K):
    """Computes both the fitness (payoff) and the number of local peaks."""
    fitness = compute_fitness(array, K)
    local_peaks = count_local_peaks(array)

    return {'payoff': fitness, 'local_peaks': local_peaks}

# -------------------------------
# Sequential Simulation Case (With Interaction)
# -------------------------------
def simulate_sequential_1(iteration, N1, K1, N2, K3):
    """
    Case 2.1: Body-1 updates first using (N1, K1), then feeds the first K3 elements
    to Body-2, which updates using (N2, K3). (K2 is ignored here).
    """
    body1 = create_updated_array(N1, K1)

    if K3 <= 0 or K3 > len(body1):
        body2 = [0] * N2
    else:
        seed_for_body2 = body1[:K3]
        body2 = create_updated_array_n2(N2, K3, initial_seed=seed_for_body2)

    payoff_body1 = compute_payoff(body1, K1)
    payoff_body2 = compute_payoff(body2, K3)

    avg_payoff = (payoff_body1['payoff'] + payoff_body2['payoff']) / 2

    return {
        'Simulation': iteration,
        'N_AI': N1, 'K_AI': K1, 'N_Human': N2, 'K_Human': 0, 'C': K3,
        'LP_AI': payoff_body1['local_peaks'],
        'PO_AI': payoff_body1['payoff'],
        'UA_AI': body1,
        'LP_Human': payoff_body2['local_peaks'],
        'PO_Human': payoff_body2['payoff'],
        'UA_Human': body2,
        'APO_Sequential_ATH': avg_payoff
    }

# -------------------------------------
# MAIN SIMULATION EXECUTION
# -------------------------------------
def main_simulation(iteration):
    # Define parameter ranges
    N1_values = range(1, 51)
    N2_values = range(1, 11)
    # K1_values = range(0, 10)
    # K3_values = range(0, 10)  # K3 replaces K2 in sequential case

    # Generate all valid configurations (K1 < N1, K3 < N2)
    configs = [(N1, K1, N2, K3)
               for N1 in N1_values for K1 in range(0, N1)
               for N2 in N2_values for K3 in range(1, N2)]

    results = []

    for config in configs:
        N1, K1, N2, K3 = config
        result = simulate_sequential_1(iteration, N1, K1, N2, K3)
        results.append(result)
        print(result)  # Print structured output

    # Convert to DataFrame for structured output
    results_df = pd.DataFrame(results)

    # Define the filename
    filename = "sequential_simulation_results_ath.csv"

    # Check if file exists -> Append data (without writing the header again)
    if os.path.exists(filename):
        results_df.to_csv(filename, mode='a', header=False, index=False)
    else:
        results_df.to_csv(filename, mode='w', header=True, index=False)

    return results_df

# -------------------------------------
# EXECUTION ENTRY POINT
# -------------------------------------
if __name__ == "__main__":
    for iteration_id in range(1, 11):  # Example: Running 10 iterations
        df = main_simulation(iteration_id)
        print(f"Iteration {iteration_id} completed.")
    print("All iterations completed.")

"""### **HTA Sequence - Updated**"""

# -------------------------------
# Updating Rule for AI (N_AI, K_AI)
# -------------------------------
def create_updated_array(N_AI, K_AI, initial_seed=None):
    """Generates an updated array for AI using a sliding window update rule based on K_AI."""
    if K_AI <= 0:
        return [0] * N_AI

    if initial_seed is None or len(initial_seed) != K_AI:
        initial_seed = [random.choice([0, 1]) for _ in range(K_AI)]

    result = list(initial_seed)

    while len(result) < N_AI:
        window = result[-K_AI:]
        avg = sum(window) / K_AI
        next_element = 1 if avg >= 0.5 else 0
        result.append(next_element)

    return result

# -------------------------------
# Updating Rule for Human (N_Human, K_Human)
# -------------------------------
def create_updated_array_n2(N_Human, K_Human, initial_seed=None):
    """Generates an updated array for Human using a weighted sliding window update rule based on K_Human."""
    if K_Human <= 0:
        return [0] * N_Human

    if initial_seed is None or len(initial_seed) != K_Human:
        initial_seed = [random.choice([0, 1]) for _ in range(K_Human)]

    result = list(initial_seed)
    total_weight = sum(range(1, K_Human + 1))

    while len(result) < N_Human:
        window = result[-K_Human:]
        weighted_sum = sum((i + 1) * window[i] for i in range(K_Human))
        next_element = 1 if weighted_sum >= total_weight / 2 else 0
        result.append(next_element)

    return result

# -------------------------------
# Fitness and Local Peaks Calculation
# -------------------------------
def compute_fitness(array, K):
    """Computes the fitness (payoff) based on the interactions in the array."""
    N = len(array)
    if N == 0:
        return 0

    total_fitness = 0
    for i in range(N):
        interacting_indices = [(i + j) % N for j in range(K + 1)]
        interacting_values = [array[j] for j in interacting_indices]
        fitness_contribution = sum(interacting_values) % 2
        total_fitness += fitness_contribution

    return total_fitness / N

def count_local_peaks(array):
    """Counts the number of local peaks in an array."""
    N = len(array)
    if N == 0:
        return 0

    peak_count = 0
    for i in range(N):
        left_neighbor = array[i - 1] if i > 0 else array[N - 1]
        right_neighbor = array[i + 1] if i < N - 1 else array[0]

        if array[i] >= left_neighbor and array[i] >= right_neighbor:
            peak_count += 1

    return peak_count

def compute_payoff(array, K):
    """Computes both the fitness (payoff) and the number of local peaks."""
    fitness = compute_fitness(array, K)
    local_peaks = count_local_peaks(array)

    return {'PO': fitness, 'NLP': local_peaks}

def simulate_hta(iteration, N_AI, K_AI, N_Human, K_Human, C, AI_updation="rule-based"):
    """
    Simulates the Human-to-AI (HTA) Sequential Case where the human updates first and seeds AI.

    AI_updation: "rule-based" → AI continues updating using its usual sliding-window rule.
                 "hallucination" → AI starts random updates once S_AI = N_H.
    """

    # Step 1: Human generates its sequence
    UA_Human = create_updated_array_n2(N_Human, K_Human)

    # Step 2: AI starts with the first C elements of UA_Human
    seed_for_AI = UA_Human[:C]

    # Step 3: Generate full AI array using AI's update rule
    UA_AI = create_updated_array(N_AI, C, initial_seed=seed_for_AI)

    # Step 4: Adjust AI's update method after S_AI = N_H
    AI_Updation_Type = AI_updation  # Track whether AI updates using rule-based or hallucination
    if len(UA_AI) > N_Human:
        if AI_updation == "hallucination":
            for i in range(N_Human, N_AI):  # AI starts hallucinating after N_H elements
                UA_AI[i] = random.choice([0, 1])  # Randomly assign 0 or 1

    # Step 5: Compute fitness and payoff for AI and Human
    PO_AI = compute_payoff(UA_AI, K_AI)
    PO_Human = compute_payoff(UA_Human, K_Human)

    # Step 6: Compute Average Payoff
    APO = (PO_AI['PO'] + PO_Human['PO']) / 2

    return {
        'Iteration': iteration, 'N_AI': N_AI, 'K_AI': K_AI, 'N_Human': N_Human, 'K_Human': K_Human, 'C': C,
        'NLP_AI': PO_AI['NLP'], 'PO_AI': PO_AI['PO'], 'UA_AI': UA_AI,
        'NLP_Human': PO_Human['NLP'], 'PO_Human': PO_Human['PO'], 'UA_Human': UA_Human,
        'APO': APO, 'AI_Updation_Type': AI_Updation_Type  # Key column to indicate rule-based vs. hallucination
    }

def main_simulation(iteration):
    N_AI_values = range(1, 51)  # N_AI can be any value in this range
    N_Human_values = range(1, 11)  # N_H can be any value in this range

    # Ensure valid (N_AI, N_H, K_H, C) configurations based on constraints
    configs = [(N_AI, 0, N_Human, K_Human, C)
               for N_AI in N_AI_values
               for N_Human in N_Human_values
               for K_Human in range(0, N_Human + 1)
               for C in range(1, N_Human)]  # C in [1, N_H), excluding C=0

    results = []

    for config in configs:
        N_AI, K_AI, N_Human, K_Human, C = config

        # Choose either rule-based or hallucination dynamically
        AI_updation = "rule-based" if random.random() < 0.5 else "hallucination"

        # Run HTA simulation with one consistent AI approach
        result = simulate_hta(iteration, N_AI, K_AI, N_Human, K_Human, C, AI_updation=AI_updation)
        results.append(result)

    df = pd.DataFrame(results)
    filename = "simulation_results_hta.csv"

    if os.path.exists(filename):
        df.to_csv(filename, mode='a', header=False, index=False)
    else:
        df.to_csv(filename, mode='w', header=True, index=False)

# -------------------------------------
# EXECUTION ENTRY POINT
# -------------------------------------
if __name__ == "__main__":
    for iteration_id in range(1, 2):
        df = main_simulation(iteration_id)
        print(f"Iteration {iteration_id} completed.")
    print("All iterations completed.")